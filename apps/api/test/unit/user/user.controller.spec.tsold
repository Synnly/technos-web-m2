import { UserController } from "../../../src/user/user.controller";
import { UserService } from "../../../src/user/user.service";
import { Test } from "@nestjs/testing";
import { Role, User } from "../../../src/user/user.schema";
import { APP_GUARD } from "@nestjs/core";
import { JwtService } from "@nestjs/jwt";
import { BadRequestException, NotFoundException, UnauthorizedException, ForbiddenException } from "@nestjs/common";
import { CosmeticService } from "../../../src/cosmetic/cosmetic.service";
import { getModelToken } from "@nestjs/mongoose";
import { CosmeticType } from "../../../src/cosmetic/cosmetic.schema";
import { Model } from "mongoose";

const expectedUser1 = {
	_id: "1",
	username: "testuser1",
	motDePasse: "H@sh3dpassword",
	points: 50,
	dateDerniereRecompenseQuotidienne: null,
	predictions: [],
	votes: [],
	role: "user",
	cosmeticsOwned: [],
	currentCosmetic: [],
} as User;

const expectedUser2 = {
	_id: "2",
	username: "testuser2",
	motDePasse: "H@sh3dpassword2",
	points: 100,
	dateDerniereRecompenseQuotidienne: new Date(),
	predictions: [],
	votes: [],
	role: "user",
	cosmeticsOwned: [],
	currentCosmetic: [],
} as User;

const expectedUsers = [expectedUser1, expectedUser2];

const mockUserService = {
	getAll: jest.fn(),
	getByUsername: jest.fn(),
	createUser: jest.fn(),
	createOrUpdateByUsername: jest.fn(),
	deleteByUsername: jest.fn(),
	getJwtToken: jest.fn(),
	claimDailyReward: jest.fn(),
	buyCosmetic: jest.fn(),
};

// Mock du JwtService
const mockJwtService = {
	sign: jest.fn().mockReturnValue("mock-jwt-token"),
	verify: jest.fn(),
};

const mockCosmeticService = {
	findAll: jest.fn(),
	findById: jest.fn(),
	create: jest.fn(),
	updateById: jest.fn(),
	deleteById: jest.fn(),
};

interface MockCosmeticModel {
	new (data: any): { save: jest.Mock; [key: string]: any };
	find: jest.Mock;
	findById: jest.Mock;
	findByIdAndUpdate: jest.Mock;
	findByIdAndDelete: jest.Mock;
	findOne: jest.Mock;
}

const mockCosmeticModel = jest.fn().mockImplementation((data) => ({
	...data,
	save: jest.fn().mockResolvedValue({
		_id: "3",
		...data,
		owned: false,
	}),
})) as unknown as MockCosmeticModel;

const mockUserModel = {
	findOne: jest.fn().mockReturnValue({ exec: jest.fn().mockResolvedValue(expectedUser1) }),
	findById: jest.fn().mockReturnValue({ exec: jest.fn().mockResolvedValue(expectedUser1) }),
	find: jest.fn().mockReturnValue({
		exec: jest.fn().mockResolvedValue([expectedUser1, expectedUser2]),
	}),
	findByIdAndUpdate: jest.fn().mockReturnValue({ exec: jest.fn().mockResolvedValue(expectedUser1) }),
	create: jest.fn().mockResolvedValue(expectedUser1),
} as any;

describe("UserController", () => {
	let userService: UserService;
	let userController: UserController;

	// Initialiser le module de test avant chaque test
	beforeEach(async () => {
		jest.clearAllMocks();

		const moduleRef = await Test.createTestingModule({
			controllers: [UserController],
			providers: [
				{
					provide: UserService,
					useValue: mockUserService,
				},
				{
					provide: JwtService,
					useValue: mockJwtService,
				},
				{
					provide: CosmeticService,
					useValue: mockCosmeticService,
				},
				{
					provide: getModelToken("Cosmetic"),
					useValue: mockCosmeticModel,
				},
				{
					provide: Model,
					useValue: mockUserModel,
				},
				{
					provide: getModelToken(User.name),
					useValue: mockUserModel,
				},
				{ provide: APP_GUARD, useValue: { canActivate: () => true } },
			],
		}).compile();

		userService = moduleRef.get(UserService);
		userController = moduleRef.get(UserController);
	});

	describe("getUsers", () => {
		it("should return all users", async () => {
			mockUserService.getAll.mockResolvedValue(expectedUsers);

			await userController.getUsers();

			expect(userService.getAll).toHaveBeenCalled();
		});
	});

	describe("getUsers", () => {
		it("should return no users when no users exist", async () => {
			mockUserService.getAll.mockResolvedValue([]);

			await userController.getUsers();

			expect(userService.getAll).toHaveBeenCalled();
		});
	});

	describe("getUserByUsername", () => {
		it("should return a user when found", async () => {
			const username = "testuser";

			// Configuration du mock pour retourner l'utilisateur attendu
			mockUserService.getByUsername.mockResolvedValue(expectedUser1);

			await userController.getUserByUsername(username);

			expect(userService.getByUsername).toHaveBeenCalledWith(username);
		});
	});

	describe("getUserByUsername", () => {
		it("should return 404 when user is not found by correct username", async () => {
			const username = "unknownuser";

			// Configuration du mock pour retourner null (utilisateur non trouvé)
			mockUserService.getByUsername.mockResolvedValue(null);

			await expect(userController.getUserByUsername(username)).rejects.toThrow(NotFoundException);

			expect(userService.getByUsername).toHaveBeenCalledWith(username);
		});
	});

	describe("getUserByUsername", () => {
		it("should return 404 when user is not found by empty username", async () => {
			const username = "";

			// Configuration du mock pour retourner null (utilisateur non trouvé)
			mockUserService.getByUsername.mockResolvedValue(null);

			await expect(userController.getUserByUsername(username)).rejects.toThrow(NotFoundException);

			expect(userService.getByUsername).toHaveBeenCalledWith(username);
		});
	});

	describe("createUser", () => {
		it("should return a 201 when a user is created", async () => {
			// Configuration du mock pour retourner l'utilisateur créé
			mockUserService.createUser.mockResolvedValue(expectedUser1);

			await userController.createUser(expectedUser1);

			expect(userService.createUser).toHaveBeenCalledWith(expectedUser1);
		});
	});

	describe("createUser", () => {
		it("should return a 400 if the user already exists", async () => {
			mockUserService.createUser.mockImplementation(() => {
				throw new Error("Username déjà utilisé.");
			});

			await expect(userController.createUser(expectedUser1)).rejects.toThrow(BadRequestException);

			expect(userService.createUser).toHaveBeenCalledWith(expectedUser1);
		});
	});

	describe("createUser", () => {
		it("should return a 400 if the user doesn't have a password", async () => {
			const username = "testuser";
			const newUser = { username: username } as User;

			await expect(userController.createUser(newUser)).rejects.toThrow(BadRequestException);
		});
	});

	describe("createUser", () => {
		it("should return a 400 if the user doesn't have a username", async () => {
			const motDePasse = "testpassword";
			const newUser = { motDePasse: motDePasse } as User;

			await expect(userController.createUser(newUser)).rejects.toThrow(BadRequestException);
		});
	});

	describe("createUser", () => {
		it("should return a 400 if the password is too short", async () => {
			const newUser = {
				username: "testuser",
				motDePasse: "Short1!",
			} as User;

			await expect(userController.createUser(newUser)).rejects.toThrow(BadRequestException);
		});
	});

	describe("createUser", () => {
		it("should return a 400 if the password doesn't contain an uppercase letter", async () => {
			const newUser = {
				username: "testuser",
				motDePasse: "lowercase123!",
			} as User;

			await expect(userController.createUser(newUser)).rejects.toThrow(BadRequestException);
		});
	});

	describe("createUser", () => {
		it("should return a 400 if the password doesn't contain a lowercase letter", async () => {
			const newUser = {
				username: "testuser",
				motDePasse: "UPPERCASE123!",
			} as User;

			await expect(userController.createUser(newUser)).rejects.toThrow(BadRequestException);
		});
	});

	describe("createUser", () => {
		it("should return a 400 if the password doesn't contain a digit", async () => {
			const newUser = {
				username: "testuser",
				motDePasse: "NoDigits!",
			} as User;

			await expect(userController.createUser(newUser)).rejects.toThrow(BadRequestException);
		});
	});

	describe("createUser", () => {
		it("should return a 400 if the password doesn't contain a special character", async () => {
			const newUser = {
				username: "testuser",
				motDePasse: "NoSpecial123",
			} as User;

			await expect(userController.createUser(newUser)).rejects.toThrow(BadRequestException);
		});
	});

	describe("updateUserByUsername", () => {
		it("should return a 200 when a user is updated", async () => {
			// Configuration du mock pour retourner l'utilisateur créé
			mockUserService.createOrUpdateByUsername.mockResolvedValue(expectedUser1);

			const mockReq = {
				user: {
					_id: (expectedUser1 as any)._id,
					role: expectedUser1.role,
					username: expectedUser1.username,
				},
			} as any;

			// Utiliser le même username que dans mockReq.user.username pour passer la vérification de permission
			await userController.updateUserByUsername(mockReq, expectedUser1.username, expectedUser1);

			expect(userService.createOrUpdateByUsername).toHaveBeenCalledWith(expectedUser1.username, expectedUser1);
		});
	});

	describe("updateUserByUsername", () => {
		it("should return a 200 when a user's username is updated", async () => {
			const updatedUser = {
				...expectedUser1,
				username: "updatedUsername",
			} as User;

			// Configuration du mock pour retourner l'utilisateur créé
			mockUserService.createOrUpdateByUsername.mockResolvedValue(updatedUser);

			const mockReq = {
				user: {
					_id: (expectedUser1 as any)._id,
					role: expectedUser1.role,
					username: expectedUser1.username,
				},
			} as any;
			await userController.updateUserByUsername(mockReq, expectedUser1.username, updatedUser);

			expect(userService.createOrUpdateByUsername).toHaveBeenCalledWith(expectedUser1.username, updatedUser);
		});
	});

	describe("updateUserByUsername", () => {
		it("should return a 200 when a user's password is updated", async () => {
			const updatedUser = {
				...expectedUser1,
				motDePasse: "updatedMotDePasse",
			} as User;

			// Configuration du mock pour retourner l'utilisateur créé
			mockUserService.createOrUpdateByUsername.mockResolvedValue(updatedUser);

			const mockReq = {
				user: {
					_id: (expectedUser1 as any)._id,
					role: expectedUser1.role,
					username: expectedUser1.username,
				},
			} as any;

			await userController.updateUserByUsername(mockReq, expectedUser1.username, updatedUser);

			expect(userService.createOrUpdateByUsername).toHaveBeenCalledWith(expectedUser1.username, updatedUser);
		});
	});

	describe("updateUserByUsername", () => {
		it("should return a 200 when a user's points is updated", async () => {
			const updatedUser = { ...expectedUser1, points: 200 } as User;

			// Configuration du mock pour retourner l'utilisateur créé
			mockUserService.createOrUpdateByUsername.mockResolvedValue(updatedUser);

			const mockReq = {
				user: {
					_id: (expectedUser1 as any)._id,
					role: expectedUser1.role,
					username: expectedUser1.username,
				},
			} as any;

			await userController.updateUserByUsername(mockReq, expectedUser1.username, updatedUser);

			expect(userService.createOrUpdateByUsername).toHaveBeenCalledWith(expectedUser1.username, updatedUser);
		});
	});

	describe("updateUserByUsername", () => {
		it("should return a 200 when a user's dateDerniereRecompenseQuotidienne is updated", async () => {
			const updatedUser = {
				...expectedUser1,
				dateDerniereRecompenseQuotidienne: new Date(),
			} as User;

			// Configuration du mock pour retourner l'utilisateur créé
			mockUserService.createOrUpdateByUsername.mockResolvedValue(updatedUser);

			const mockReq = {
				user: {
					_id: (expectedUser1 as any)._id,
					role: expectedUser1.role,
					username: expectedUser1.username,
				},
			} as any;

			await userController.updateUserByUsername(mockReq, expectedUser1.username, updatedUser);

			expect(userService.createOrUpdateByUsername).toHaveBeenCalledWith(expectedUser1.username, updatedUser);
		});
	});

	describe("updateUserByUsername", () => {
		it("should return a 200 when a user is updated to the same user", async () => {
			// Configuration du mock pour retourner l'utilisateur créé
			mockUserService.createOrUpdateByUsername.mockResolvedValue(expectedUser1);

			const mockReq = {
				user: {
					_id: (expectedUser1 as any)._id,
					role: expectedUser1.role,
					username: expectedUser1.username,
				},
			} as any;
			await userController.updateUserByUsername(mockReq, expectedUser1.username, expectedUser1);

			expect(userService.createOrUpdateByUsername).toHaveBeenCalledWith(expectedUser1.username, expectedUser1);
		});
	});

	describe("updateUserByUsername", () => {
		it("should return a 200 if the user doesn't have a password", async () => {
			const username = "testuser";
			const noPasswordUser = { username: username } as User;

			const mockReq = {
				user: {
					_id: (expectedUser1 as any)._id,
					role: expectedUser1.role,
					username: expectedUser1.username,
				},
			} as any;

			await userController.updateUserByUsername(mockReq, expectedUser1.username, noPasswordUser);

			expect(userService.createOrUpdateByUsername).toHaveBeenCalledWith(expectedUser1.username, noPasswordUser);
		});
	});

	describe("updateUserByUsername", () => {
		it("should return a 200 if the user doesn't have a username", async () => {
			const motDePasse = "testpassword";
			const noUsernameUser = { motDePasse: motDePasse } as User;

			const mockReq = {
				user: {
					_id: (expectedUser1 as any)._id,
					role: expectedUser1.role,
					username: expectedUser1.username,
				},
			} as any;

			await userController.updateUserByUsername(mockReq, expectedUser1.username, noUsernameUser);
		});
	});

	describe("updateUserByUsername", () => {
		it("should return a 200 when a user is updated with empty object", async () => {
			const updatedUser = {} as User;

			// Configuration du mock pour retourner l'utilisateur créé
			mockUserService.createOrUpdateByUsername.mockResolvedValue(expectedUser1);

			const mockReq = {
				user: {
					_id: (expectedUser1 as any)._id,
					role: expectedUser1.role,
					username: expectedUser1.username,
				},
			} as any;

			await userController.updateUserByUsername(mockReq, expectedUser1.username, updatedUser);

			expect(userService.createOrUpdateByUsername).toHaveBeenCalledWith(expectedUser1.username, updatedUser);
		});
	});

	describe("deleteUser", () => {
		it("should delete the user when given a valid user", async () => {
			const username = expectedUser1.username;

			// Configuration du mock pour retourner l'utilisateur attendu
			mockUserService.deleteByUsername.mockResolvedValue(expectedUser1);

			await userController.deleteUser(username);

			expect(userService.deleteByUsername).toHaveBeenCalledWith(username);
		});
	});

	describe("deleteUser", () => {
		it("should return a 404 when the user doesn't exist", async () => {
			const username = "wrongUsername";

			mockUserService.deleteByUsername.mockImplementation(() => {
				throw new Error("L'utilisateur n'est pas trouvable");
			});

			await expect(userController.deleteUser(username)).rejects.toThrow(NotFoundException);

			expect(userService.deleteByUsername).toHaveBeenCalledWith(username);
		});
	});

	describe("deleteUser", () => {
		it("should return a 400 when no username is given", async () => {
			const username = "";

			await expect(userController.deleteUser(username)).rejects.toThrow(BadRequestException);
		});
	});

	describe("getJwtToken", () => {
		it("should return the token when given a valid user", async () => {
			const token = "token";

			// Configuration du mock pour retourner l'utilisateur attendu
			mockUserService.getJwtToken.mockResolvedValue(token);

			await userController.login({
				username: expectedUser1.username,
				password: expectedUser1.motDePasse,
			});

			expect(userService.getJwtToken).toHaveBeenCalledWith(
				expectedUser1.username,
				expectedUser1.motDePasse,
				mockJwtService,
			);
		});
	});

	describe("getJwtToken", () => {
		it("should return  a 400 when no username is given", async () => {
			mockUserService.getJwtToken.mockImplementation(() => {
				throw new Error("Le nom d'utilisateur est requis");
			});

			await expect(
				userController.login({
					username: "",
					password: expectedUser1.motDePasse,
				}),
			).rejects.toThrow(BadRequestException);
		});
	});

	describe("getJwtToken", () => {
		it("should return  a 400 when no password is given", async () => {
			mockUserService.getJwtToken.mockImplementation(() => {
				throw new Error("Le mot de passe est requis");
			});

			await expect(
				userController.login({
					username: expectedUser1.username,
					password: "",
				}),
			).rejects.toThrow(BadRequestException);
		});
	});

	describe("getJwtToken", () => {
		it("should return  a 403 when a unknown username is given", async () => {
			const token = "token";

			mockUserService.getJwtToken.mockImplementation(() => {
				throw new Error("Identifiants incorrects.");
			});

			await expect(
				userController.login({
					username: "unkonwnUser",
					password: expectedUser1.motDePasse,
				}),
			).rejects.toThrow(UnauthorizedException);
		});
	});

	describe("getJwtToken", () => {
		it("should return  a 403 when the wrong password is given", async () => {
			const token = "token";

			mockUserService.getJwtToken.mockImplementation(() => {
				throw new Error("Identifiants incorrects.");
			});

			await expect(
				userController.login({
					username: expectedUser1.username,
					password: "wrongPassword",
				}),
			).rejects.toThrow(UnauthorizedException);
		});
	});

	describe("getDailyReward", () => {
		it("should return the daily reward when valid username is provided", async () => {
			const reward = 10;
			const username = expectedUser1.username;

			// Configuration du mock pour retourner la récompense
			mockUserService.claimDailyReward.mockResolvedValue(reward);

			await userController.getDailyReward(username);

			expect(userService.claimDailyReward).toHaveBeenCalledWith(username);
		});

		it("should return a 400 when no username is provided", async () => {
			const username = "";

			await expect(userController.getDailyReward(username)).rejects.toThrow(BadRequestException);
		});

		it("should return a 404 when user is not found", async () => {
			const username = "unknownuser";

			mockUserService.claimDailyReward.mockImplementation(() => {
				throw new Error("L'utilisateur n'est pas trouvable");
			});

			await expect(userController.getDailyReward(username)).rejects.toThrow(BadRequestException);

			expect(userService.claimDailyReward).toHaveBeenCalledWith(username);
		});

		it("should return a 400 when daily reward already claimed today", async () => {
			const username = expectedUser1.username;

			mockUserService.claimDailyReward.mockImplementation(() => {
				throw new Error("Récompense quotidienne déjà réclamée aujourd'hui.");
			});

			await expect(userController.getDailyReward(username)).rejects.toThrow(BadRequestException);

			expect(userService.claimDailyReward).toHaveBeenCalledWith(username);
		});
	});

	describe("buyCosmetic", () => {
		it("should buy a cosmetic when everything is valid", async () => {
			const cosmeticId = "cos1";
			const username = expectedUser1.username;
			mockUserModel.findOne.mockReturnValue({
				exec: jest.fn().mockResolvedValue(expectedUser1),
			});
			mockCosmeticService.findById.mockResolvedValue({
				_id: cosmeticId,
				cost: 10,
			});
			const mockReq = {
				user: { id: (expectedUser1 as any)._id, cosmeticsOwned: [] },
			} as any;
			mockUserService.buyCosmetic.mockResolvedValue(expectedUser1);

			await userController.buyCosmetic(cosmeticId, username, mockReq);

			expect(mockUserModel.findOne).toHaveBeenCalledWith({ username });
			expect(mockCosmeticService.findById).toHaveBeenCalledWith(cosmeticId);
			expect(userService.buyCosmetic).toHaveBeenCalledWith(
				expectedUser1,
				expect.objectContaining({ _id: cosmeticId }),
			);
		});

		it("should throw NotFoundException when user not found", async () => {
			const cosmeticId = "cos1";
			const username = "unknown";
			mockUserModel.findOne.mockReturnValue({
				exec: jest.fn().mockResolvedValue(null),
			});
			const mockReq = { user: { id: "x", cosmeticsOwned: [] } } as any;

			await expect(userController.buyCosmetic(cosmeticId, username, mockReq)).rejects.toThrow(NotFoundException);
		});

		it("should throw BadRequestException when cosmeticId is missing", async () => {
			const cosmeticId = "";
			const username = expectedUser1.username;
			mockUserModel.findOne.mockReturnValue({
				exec: jest.fn().mockResolvedValue(expectedUser1),
			});
			const mockReq = {
				user: { id: (expectedUser1 as any)._id, cosmeticsOwned: [] },
			} as any;

			await expect(userController.buyCosmetic(cosmeticId, username, mockReq)).rejects.toThrow(
				BadRequestException,
			);
		});

		it("should throw ForbiddenException when request user id doesn't match search user", async () => {
			const cosmeticId = "cos1";
			const username = expectedUser1.username;
			mockUserModel.findOne.mockReturnValue({
				exec: jest.fn().mockResolvedValue(expectedUser1),
			});
			const mockReq = {
				user: { id: "otherId", cosmeticsOwned: [] },
			} as any;

			await expect(userController.buyCosmetic(cosmeticId, username, mockReq)).rejects.toThrow(ForbiddenException);
		});

		it("should throw BadRequestException when user already owns cosmetic", async () => {
			const cosmeticId = "cos1";
			const username = expectedUser1.username;
			mockUserModel.findOne.mockReturnValue({
				exec: jest.fn().mockResolvedValue(expectedUser1),
			});
			const mockReq = {
				user: {
					id: (expectedUser1 as any)._id,
					cosmeticsOwned: [cosmeticId],
				},
			} as any;

			await expect(userController.buyCosmetic(cosmeticId, username, mockReq)).rejects.toThrow(
				BadRequestException,
			);
		});

		it("should throw NotFoundException when cosmetic does not exist", async () => {
			const cosmeticId = "cos1";
			const username = expectedUser1.username;
			mockUserModel.findOne.mockReturnValue({
				exec: jest.fn().mockResolvedValue(expectedUser1),
			});
			mockCosmeticService.findById.mockResolvedValue(null);
			const mockReq = {
				user: { id: (expectedUser1 as any)._id, cosmeticsOwned: [] },
			} as any;

			await expect(userController.buyCosmetic(cosmeticId, username, mockReq)).rejects.toThrow(NotFoundException);
		});

		it("should throw BadRequestException when user has insufficient points", async () => {
			const cosmeticId = "cos1";
			const username = expectedUser1.username;
			mockUserModel.findOne.mockReturnValue({
				exec: jest.fn().mockResolvedValue(expectedUser1),
			});
			mockCosmeticService.findById.mockResolvedValue({
				_id: cosmeticId,
				cost: 9999,
			});
			const mockReq = {
				user: { id: (expectedUser1 as any)._id, cosmeticsOwned: [] },
			} as any;

			await expect(userController.buyCosmetic(cosmeticId, username, mockReq)).rejects.toThrow(
				BadRequestException,
			);
		});
	});
});
